# JavaScript алгоритми та структури даних

[//]: # ([![CI]&#40;https://github.com/betelgeuseAS/js-algorithms-data/workflows/CI/badge.svg&#41;]&#40;https://github.com/betelgeuseAS/js-algorithms-data/actions?query=workflow%3ACI+branch%3Amaster&#41;)
[![codecov](https://codecov.io/gh/betelgeuseAS/js-algorithms-data/branch/master/graph/badge.svg)](https://codecov.io/gh/trekhleb/javascript-algorithms)
![repo size](https://img.shields.io/github/repo-size/betelgeuseAS/js-algorithms-data.svg)

Даний репозиторій приклади багатьох популярних алгоритмів та структур даних на основі JavaScript.

Кожен алгоритм та структура даних має свій окремий README-файл із відповідними поясненнями та посиланнями для подальшого вивчення (включаючи посилання на відео на YouTube).

_Вивчення матеріалу на інших мовах:_
[_English_](README.md)

*☝ Зверніть увагу! Даний проект призначений лише для навчальних та дослідницьких цілей, і він **не** призначений для виробництва (продакшн).*

## Структури даних

Структура даних (в програмуванні) - це спосіб організації даних в комп'ютерах. Часто разом зі структурою даних пов'язується і специфічний перелік операцій, що можуть бути виконаними над даними, організованими в таку структуру.
Точніше, структура даних - це сукупність даних цінності, взаємозв'язки між ними та функції або операції, до яких можна застосувати дані.

* [Зв'язаний список](data-structures/linked-list)
* [Двобічно зв'язаний список](data-structures/doubly-linked-list)
* [Черга](data-structures/queue)
* [Стек](data-structures/stack)
* [Геш-таблиця](data-structures/hash-table)
* [Купа, стіс або піраміда](data-structures/heap) - max and min heap versions
* [Черга з пріоритетом](data-structures/priority-queue)
* [Префіксне дерево](data-structures/trie)
* [Дерево](data-structures/tree)
  * [Двійкове дерево пошуку](data-structures/tree/binary-search-tree)
  * [АВЛ-дерево](data-structures/tree/avl-tree)
  * [Червоно-чорне дерево](data-structures/tree/red-black-tree)
  * [Дерево відрізків](data-structures/tree/segment-tree) - with min/max/sum range queries examples
  * [Дерево Фенвіка](data-structures/tree/fenwick-tree) (Binary Indexed Tree)
* [Граф (абстрактний тип даних)](data-structures/graph) (both directed and undirected)
* [Система неперетинних множин](data-structures/disjoint-set)
* [Фільтр Блума](data-structures/bloom-filter)

## Алгоритми

Алгоритм - це однозначна специфікація способу вирішення класу задач. Це набір правил, які точно визначають послідовність операцій.

* **Математика**
  * [Бітова маніпуляція](algorithms/math/bits) - встановити / отримати / оновити / очистити біти, множення / ділення на два, робити від’ємними тощо
  * [Факторіал](algorithms/math/factorial)
  * [Послідовність Фібоначчі](algorithms/math/fibonacci) - класична та закриті версії
  * [Основні фактори](algorithms/math/prime-factors) - пошук простих множників і підрахунок їх за допомогою теореми Харді-Рамануджана
  * [Тест простоти](algorithms/math/primality-test) (метод пробного поділу)
  * [Алгоритм Евкліда](algorithms/math/euclidean-algorithm) - метод обчислення найбільшого спільного дільника (НСД)
  * [Найменше спільне кратне](algorithms/math/least-common-multiple) (НСК)
  * [Решето Ератосфена](algorithms/math/sieve-of-eratosthenes) - алгоритм знаходження всіх простих чисел менших деякого цілого числа *n*
  * [Піднесення до степеня](algorithms/math/is-power-of-two) - перевірити, чи є число ступенем двох (просте та побітове рішення)
  * [Трикутник Паскаля](algorithms/math/pascal-triangle)
  * [Комплексне число](algorithms/math/complex-number) - комплексні числа та основні операції з ними
  * [Радіани & Градуси](algorithms/math/radian) - перетворення радіанів у градуси та навпаки
  * [Швидке піднесення до степеня](algorithms/math/fast-powering)
  * [Схема Горнера](algorithms/math/horner-method) - поліноміальна оцінка
  * [Розбиття числа](algorithms/math/integer-partition)
  * [Метод дотичних (метод Ньютона)](algorithms/math/square-root) - метод наближеного знаходження кореня дійсного рівняння
  * [Алгоритм Лю Хуея](algorithms/math/liu-hui) - розрахунок числа π з заданою точністю методом вписаних правильних багатокутників
  * [Дискретне перетворення Фур'є](algorithms/math/fourier-transform) - розкладання тимчасової функції (сигналу) на частотні складові
* **Множина**
  * [Декартів добуток множин](algorithms/sets/cartesian-product) - множина усіх можливих впорядкованих пар
  * [Тасування Фішера - Єйтса](algorithms/sets/fisher-yates) - створення випадкових перестановок кінцевого безлічі
  * [Булеан](algorithms/sets/power-set) - множина всіх підмножин даної множини (бітові та зворотні рішення)
  * [Перестановка](algorithms/sets/permutations) (з повтореннями та без)
  * [Комбінації](algorithms/sets/combinations) (з повтореннями та без)
  * [Пошук найдовшої спільної підпослідовності](algorithms/sets/longest-common-subsequence)
  * [Завдання пошуку найбільшою збільшується підпослідовності](algorithms/sets/longest-increasing-subsequence)
  * [Найменша загальна супер-послідовність](algorithms/sets/shortest-common-supersequence)
  * [Задача пакування рюкзака](algorithms/sets/knapsack-problem) - приклади "0/1" та "Необмежений"
  * [Максимальний підмасив](algorithms/sets/maximum-subarray) - метод «Грубої сили» та алгоритм Кадана
  * [Комбінована сума](algorithms/sets/combination-sum) - знайти всі комбінації, що утворюють конкретну суму
* **Алгоритми роботи з рядками**
  * [Відстань Геммінга](algorithms/string/hamming-distance) - число позицій, у яких відповідні цифри двох двійкових слів однакової довжини різні
  * [Відстань Левенштейна](algorithms/string/levenshtein-distance) - міра відмінності двох послідовностей символів (рядків)
  * [Алгоритм Кнута — Морріса — Пратта](algorithms/string/knuth-morris-pratt) пошук підрядків (узгодження шаблонів)
  * [Z-функція](algorithms/string/z-algorithm) - пошук підрядків (зіставлення зразків)
  * [Алгоритм Рабіна — Карпа](algorithms/string/rabin-karp) - алгоритм пошуку рядка
  * [Найбільший загальний підрядок](algorithms/string/longest-common-substring)
  * [Підбирання регулярного виразу](algorithms/string/regular-expression-matching)
* **Алгоритми пошуку**
  * [Лінійний пошук](algorithms/search/linear-search)
  * [Пошук блоків](algorithms/search/jump-search) - пошук у відсортованому масиві
  * [Двійковий пошук](algorithms/search/binary-search) - знаходження заданого значення у впорядкованому масиві
  * [Інтерполяційний алгоритм пошуку](algorithms/search/interpolation-search) - алгоритм для пошуку за заданим ключем в індексованому масиві, який впорядкований за значенням ключів
* **Алгоритми сортування**
  * [Сортування бульбашкою](algorithms/sorting/bubble-sort)
  * [Сортування вибором](algorithms/sorting/selection-sort)
  * [Сортування включенням](algorithms/sorting/insertion-sort)
  * [Пірамідальне сортування](algorithms/sorting/heap-sort)
  * [Сортування злиттям](algorithms/sorting/merge-sort)
  * [Швидке сортування](algorithms/sorting/quick-sort)
  * [Сортування Шелла](algorithms/sorting/shell-sort)
  * [Сортування підрахунком](algorithms/sorting/counting-sort)
  * [Сортування за розрядами](algorithms/sorting/radix-sort)
* **Зв’язані списки**
  * [Прямий обхід](algorithms/linked-list/traversal)
  * [Зворотний обхід](algorithms/linked-list/reverse-traversal)
* **Дерева**
  * [Пошук у глибину](algorithms/tree/depth-first-search)
  * [Пошук у ширину](algorithms/tree/breadth-first-search)
* **Графи**
  * [Пошук у глибину](algorithms/graph/depth-first-search)
  * [Пошук у ширину](algorithms/graph/breadth-first-search)
  * [Алгоритм Крускала](algorithms/graph/kruskal) - алгоритм побудови мінімального кістякового дерева зваженого неорієнтовного графа
  * [Алгоритм Дейкстри](algorithms/graph/dijkstra) - знаходження найкоротшого шляху від однієї вершини графа до всіх інших вершин
  * [Алгоритм Беллмана — Форда](algorithms/graph/bellman-ford) -  алгоритм пошуку найкоротшого шляху в зваженому графі
  * [Алгоритм Флойда — Воршелла](algorithms/graph/floyd-warshall) -  знаходження найкоротшого шляху в зваженому графі з додатними або від'ємними вагами ребер (але без від'ємнозначних циклів)
  * [Циклічний граф](algorithms/graph/detect-cycle) - граф, що складається з єдиного циклу, або, іншими словами, деякого числа вершин, з'єднаних замкнутим ланцюгом.
  * [Алгоритм Прима](algorithms/graph/prim) - жадібний алгоритм побудови мінімального кістякового дерева зваженого зв'язного неорієнтованого графа
  * [Топологічне сортування](algorithms/graph/topological-sorting) - впорядковування вершин безконтурного орієнтованого графа згідно з частковим порядком, визначеним ребрами цього графу на множині його вершин
  * [Алгоритм Тар'яна](algorithms/graph/articulation-points) - алгоритм пошуку компонент сильної зв'язності в орієнтованому графі, що працює за лінійний час
  * [Міст (теорія графів)](algorithms/graph/bridges)
  * [Ейлерів ланцюг](algorithms/graph/eulerian-path) - ланцюг у графі, який проходить кожне ребро рівно один раз
  * [Гамільтонів граф](algorithms/graph/hamiltonian-cycle) - шлях, що містить кожну вершину графа рівно один раз
  * [Компонента сильної зв'язності графа](algorithms/graph/strongly-connected-components) - Алгоритм Косараджу - алгоритм для знаходження компонент сильної зв’язності орієнтованого графу
  * [Задача комівояжера](algorithms/graph/travelling-salesman) - знаходження найвигіднішого маршруту, що проходить через вказані міста хоча б по одному разу
* **Криптографія**
  * [Хеш-функція](algorithms/cryptography/polynomial-hash) - функція, що перетворює вхідні дані будь-якого (як правило великого) розміру в дані фіксованого розміру.
  * [Шифр Цезаря (шифр зсуву)](algorithms/cryptography/caesar-cipher) - симетричний моноалфавітний алгоритм шифрування, в якому кожна буква відкритого тексту заміняється на ту, що віддалена від неї в алфавіті на сталу кількість позицій
  * [Шифр Гілла](algorithms/cryptography/hill-cipher) - поліграмний шифр підстановки, заснований на лінійній алгебрі
* **Машинне навчання**
  * [Нано-нейрон](https://github.com/trekhleb/nano-neuron) - 7 простих функцій JS, які ілюструють, як машини насправді можуть навчатися (пряме та зворотнє поширення)
  * [Метод k-найближчих сусідів](algorithms/ml/knn) - простий непараметричний класифікаційний метод, де для класифікації об'єктів у рамках простору властивостей використовуються відстані (зазвичай евклідові), пораховані до усіх інших об'єктів
  * [Кластеризація методом к–середніх](algorithms/ml/knn) - популярний метод кластеризації, — впорядкування множини об'єктів в порівняно однорідні групи.
* **Без категорії**
  * [Ханойська вежа](algorithms/uncategorized/hanoi-tower)
  * [Поворот квадратної матриці](algorithms/uncategorized/square-matrix-rotation)
  * [Гра стрибків](algorithms/uncategorized/jump-game) - зворотне відстеження, динамічне програмування (зверху вниз + знизу вгору) та жадібні приклади
  * [Проблема унікальних шляхів](algorithms/uncategorized/unique-paths) - зворотне відстеження, динамічне програмування та приклади на основі Трикутника Паскаля
  * [Дощові тераси](algorithms/uncategorized/rain-terraces) - проблема захоплення дощової води (динамічне програмування та версії грубої сили)
  * [Завдання про рекурсивні сходи](algorithms/uncategorized/recursive-staircase) - підрахунок кількості способів досягти вершини (4 рішення)
  * [Задача про вісім ферзів](algorithms/uncategorized/n-queens)
  * [Задача про хід коня](algorithms/uncategorized/knight-tour)

### Парадигма програмування

Парадиигма програмува́ння — це система ідей і понять, які визначають стиль написання комп'ютерних програм, а також спосіб мислення програміста. Це спосіб концептуалізації, що визначає організацію обчислень і структурування роботи, яку виконує комп'ютер.

* **Метод «грубої сили» або повний перебір** - метод рішення криптографічної задачі шляхом перебору всіх можливих варіантів ключа
  * [Лінійний пошук](algorithms/search/linear-search)
  * [Дощові тераси](algorithms/uncategorized/rain-terraces) - задача про дощові тераси
  * [Завдання про рекурсивні сходи](algorithms/uncategorized/recursive-staircase) - підрахунок кількості способів досягти вершини
  * [Максимальний підмасив](algorithms/sets/maximum-subarray)
  * [Задача комівояжера](algorithms/graph/travelling-salesman) - знаходження найвигіднішого маршруту, що проходить через вказані міста хоча б по одному разу
  * [Дискретне перетворення Фур'є](algorithms/math/fourier-transform) - розкладання тимчасової функції (сигналу) на частотні складові
* **"Жадібні" алгоритми** - простий і прямолінійний евристичний алгоритм, який приймає найкраще рішення, виходячи з наявних на кожному етапі даних, не зважаючи на можливі наслідки, сподіваючись урешті-решт отримати оптимальний розв'язок
  * [Гра стрибків](algorithms/uncategorized/jump-game) - зворотне відстеження, динамічне програмування (зверху вниз + знизу вгору) та жадібні приклади
  * [Задача пакування рюкзака](algorithms/sets/knapsack-problem) - приклади "0/1" та "Необмежений"
  * [Алгоритм Дейкстри](algorithms/graph/dijkstra) - знаходження найкоротшого шляху від однієї вершини графа до всіх інших вершин
  * [Алгоритм Прима](algorithms/graph/prim) - жадібний алгоритм побудови мінімального кістякового дерева зваженого зв'язного неорієнтованого графа
  * [Алгоритм Крускала](algorithms/graph/kruskal) - алгоритм побудови мінімального кістякового дерева зваженого неорієнтовного графа
* **Розділяй і володарюй** - важлива парадигма розробки алгоритмів, що полягає в рекурсивному розбитті розв'язуваної задачі на дві або більше підзадачі того ж типу, але меншого розміру, і комбінуванні їх розв'язків для отримання відповіді до вихідного завдання. Розбиття виконуються доти, поки всі підзавдання не стануть елементарними.
  * [Двійковий пошук](algorithms/search/binary-search) - знаходження заданого значення у впорядкованому масиві
  * [Ханойська вежа](algorithms/uncategorized/hanoi-tower)
  * [Трикутник Паскаля](algorithms/math/pascal-triangle)
  * [Алгоритм Евкліда](algorithms/math/euclidean-algorithm) - метод обчислення найбільшого спільного дільника (НСД)
  * [Сортування злиттям](algorithms/sorting/merge-sort)
  * [Швидке сортування](algorithms/sorting/quick-sort)
  * [Пошук у глибину](algorithms/tree/depth-first-search)
  * [Пошук у ширину](algorithms/tree/breadth-first-search)
  * [Гра стрибків](algorithms/uncategorized/jump-game) - зворотне відстеження, динамічне програмування (зверху вниз + знизу вгору) та жадібні приклади
  * [Швидке піднесення до степеня](algorithms/math/fast-powering)
  * [Перестановка](algorithms/sets/permutations) (з повтореннями та без)
  * [Комбінації](algorithms/sets/combinations) (з повтореннями та без)
* **Динамічне програмування** - розділ математики, який присвячено теорії і методам розв'язання багатокрокових задач оптимального управління
  * [Послідовність Фібоначчі](algorithms/math/fibonacci) - класична та закриті версії
  * [Гра стрибків](algorithms/uncategorized/jump-game) - зворотне відстеження, динамічне програмування (зверху вниз + знизу вгору) та жадібні приклади
  * [Проблема унікальних шляхів](algorithms/uncategorized/unique-paths) - зворотне відстеження, динамічне програмування та приклади на основі Трикутника Паскаля
  * [Дощові тераси](algorithms/uncategorized/rain-terraces) - проблема захоплення дощової води (динамічне програмування та версії грубої сили)
  * [Завдання про рекурсивні сходи](algorithms/uncategorized/recursive-staircase) - підрахунок кількості способів досягти вершини (4 рішення)
  * [Відстань Левенштейна](algorithms/string/levenshtein-distance) - міра відмінності двох послідовностей символів (рядків)
  * [Пошук найдовшої спільної підпослідовності](algorithms/sets/longest-common-subsequence)
  * [Найбільший загальний підрядок](algorithms/string/longest-common-substring)
  * [Завдання пошуку найбільшою збільшується підпослідовності](algorithms/sets/longest-increasing-subsequence)
  * [Найменша загальна супер-послідовність](algorithms/sets/shortest-common-supersequence)
  * [Задача пакування рюкзака](algorithms/sets/knapsack-problem) - приклади "0/1" та "Необмежений"
  * [Розбиття числа](algorithms/math/integer-partition)
  * [Максимальний підмасив](algorithms/sets/maximum-subarray)
  * [Алгоритм Беллмана — Форда](algorithms/graph/bellman-ford) -  алгоритм пошуку найкоротшого шляху в зваженому графі
  * [Алгоритм Флойда — Воршелла](algorithms/graph/floyd-warshall) -  знаходження найкоротшого шляху в зваженому графі з додатними або від'ємними вагами ребер (але без від'ємнозначних циклів)
  * [Підбирання регулярного виразу](algorithms/string/regular-expression-matching)
* **Пошук із зворотом** - подібно до грубої сили, намагайтеся генерувати всі можливі рішення, але кожного разу, коли ви створюєте наступне рішення, тестуєте чи він задовольняє всім умовам, і лише потім продовжуєте генерувати наступні рішення. В іншому випадку поверніться назад і рухайтесь далі іншим шляхом пошуку рішення.
  * [Гра стрибків](algorithms/uncategorized/jump-game) - зворотне відстеження, динамічне програмування (зверху вниз + знизу вгору) та жадібні приклади
  * [Проблема унікальних шляхів](algorithms/uncategorized/unique-paths) - зворотне відстеження, динамічне програмування та приклади на основі Трикутника Паскаля
  * [Булеан](algorithms/sets/power-set) - множина всіх підмножин даної множини (бітові та зворотні рішення)
  * [Гамільтонів граф](algorithms/graph/hamiltonian-cycle) - шлях, що містить кожну вершину графа рівно один раз
  * [Задача про вісім ферзів](algorithms/uncategorized/n-queens)
  * [Задача про хід коня](algorithms/uncategorized/knight-tour)
  * [Комбінована сума](algorithms/sets/combination-sum) - знайти всі комбінації, що утворюють конкретну суму
* **Метод гілок і меж** - один з поширених методів дискретної оптимізації. Метод працює на дереві рішень та визначає принципи роботи конкретних алгоритмів пошуку розв'язків, тобто, є мета-алгоритмом. Для різних задач комбінаторної оптимізації створюють спеціалізовані алгоритми гілок та меж.

## Корисна інформація

### Список літератури

[▶ Структури даних та алгоритми на YouTube](https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)

### Асимптотична нотація великого О (нотація Ландау)

*Асимптотична нотація великого О (нотація Ландау)* розповсюджена математична нотація для формального запису асимптотичної поведінки функцій. Широко вживається в теорії складності обчислень, інформатиці та математиці.
![Асимптотична нотація великого О](./assets/big-o-graph.png)

Джерело: [Асимптотична нотація великого О](http://bigocheatsheet.com/).

Нижче наведено список деяких найбільш часто використовуваних позначень нотації Ландаута їх порівняння продуктивності з різними розмірами вхідних даних.

| Нотація Ландау | Обчислення для 10 елементів | Обчислення для 100 елементів | Обчислення для 1000 елементів  |
| -------------- | ---------------------------- | ----------------------------- | ------------------------------- |
| **O(1)**       | 1                            | 1                             | 1                               |
| **O(log N)**   | 3                            | 6                             | 9                               |
| **O(N)**       | 10                           | 100                           | 1000                            |
| **O(N log N)** | 30                           | 600                           | 9000                            |
| **O(N^2)**     | 100                          | 10000                         | 1000000                         |
| **O(2^N)**     | 1024                         | 1.26e+29                      | 1.07e+301                       |
| **O(N!)**      | 3628800                      | 9.3e+157                      | 4.02e+2567                      |

### Складність операцій в структурі даних

| Структура даних        | Доступ    | Пошук    | Вставка | Видалення  | Коментарі  |
| ----------------------- | :-------: | :-------: | :-------: | :-------: | :-------- |
| **Масив**               | 1         | n         | n         | n         |           |
| **Купа**               | n         | n         | 1         | 1         |           |
| **Черга**               | n         | n         | 1         | 1         |           |
| **Зв’язаний список**         | n         | n         | 1         | n         |           |
| **Хеш-таблиця**          | -         | n         | n         | n         | У разі ідеальної хеш-функції - O(1) |
| **Бінарне дерево пошуку**  | n         | n         | n         | n         | У разі збалансованого дерева витрати становитимуть O (log (n)) |
| **Б-дерево**              | log(n)    | log(n)    | log(n)    | log(n)    |           |
| **Червоно-чорне дерево**      | log(n)    | log(n)    | log(n)    | log(n)    |           |
| **АВЛ-дерево**            | log(n)    | log(n)    | log(n)    | log(n)    |           |
| **Фільтр Блума**        | -         | 1         | 1         | -         | Під час пошуку можливі помилкові спрацьовування |

### Складність алгоритмів сортування масивів

| Назва                  | Найкращий            | Середній             | Найгірший               | Пам'ять    | Стабільність    | Коментарі  |
| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |
| **Сортування бульбашкою**       | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Так       |           |
| **Сортування включенням**    | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Так       |           |
| **Сортування вибором**    | n<sup>2</sup>   | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Ні        |           |
| **Пірамідальне сортування**         | n&nbsp;log(n)   | n&nbsp;log(n)       | n&nbsp;log(n)       | 1         | Ні        |           |
| **Сортування злиттям**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n&nbsp;log(n)       | n         | Так       |           |
| **Швидке сортування**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n<sup>2</sup>       | log(n)    | Ні        | Швидке сортування зазвичай виконується на місці з використанням O (log (n)) додаткової пам'яті |
| **Сортування Шелла**        | n&nbsp;log(n)   | залежить від послідовності проміжків   | n&nbsp;(log(n))<sup>2</sup>  | 1         | Ні         |           |
| **Сортування підрахунком**     | n + r           | n + r               | n + r               | n + r     | Так       | Де r - найбільше число в масиві |
| **Сортування за розрядами**        | n * k           | n * k               | n * k               | n + k     | Так       | Де k - довжина найдовшого ключа |

## Підтримати

> Ви можете підтримати цей проект через ❤️️ [Buy me coffee](https://www.buymeacoffee.com/betelgeuseo) або ❤️️ [Become a Patron](https://www.paypal.com/donate/?hosted_button_id=327N24D6QDLVC).

## Автор

[MeDev](https://betelgeuseas.github.io/me-dev/)
